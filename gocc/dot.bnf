// The DOT Language
//
// http://www.graphviz.org/doc/info/lang.html

// ### [ Tokens ] ##############################################################

// The keywords node, edge, graph, digraph, subgraph, and strict are case-
// independent.

node
	: 'n' 'o' 'd' 'e'
	| 'N' 'o' 'd' 'e'
	| 'N' 'O' 'D' 'E'
;

edge
	: 'e' 'd' 'g' 'e'
	| 'E' 'd' 'g' 'e'
	| 'E' 'D' 'G' 'E'
;

// TODO: Rename graphx to graph once gocc#20 is fixed [1].
//
// [1]: https://github.com/goccmack/gocc/issues/20

graphx
	: 'g' 'r' 'a' 'p' 'h'
	| 'G' 'r' 'a' 'p' 'h'
	| 'G' 'R' 'A' 'P' 'H'
;

digraph
	: 'd' 'i' 'g' 'r' 'a' 'p' 'h'
	| 'D' 'i' 'g' 'r' 'a' 'p' 'h'
	| 'D' 'i' 'G' 'r' 'a' 'p' 'h'
	| 'D' 'I' 'G' 'R' 'A' 'P' 'H'
;

subgraph
	: 's' 'u' 'b' 'g' 'r' 'a' 'p' 'h'
	| 'S' 'u' 'b' 'g' 'r' 'a' 'p' 'h'
	| 'S' 'u' 'b' 'G' 'r' 'a' 'p' 'h'
	| 'S' 'U' 'B' 'G' 'R' 'A' 'P' 'H'
;

strict
	: 's' 't' 'r' 'i' 'c' 't'
	| 'S' 't' 'r' 'i' 'c' 't'
	| 'S' 'T' 'R' 'I' 'C' 'T'
;

// An arbitrary ASCII character except null (0x00), new lines (0x0A), carriage
// return (0x0D), apostrophe (0x27), double quote (0x22) and backslash (0x5C).
_ascii_char
	: '\x01' - '\x09'
	| '\x0B' - '\x0C'
	| '\x0E' - '\x21'
	| '\x23' - '\x26'
	| '\x28' - '\x5B'
	| '\x5D' - '\x7F'
;

_ascii_letter : 'a' - 'z' | 'A' - 'Z' ;
_ascii_digit  : '0' - '9' ;
_letter        : _ascii_letter | '_' ;
_decimal_digit : _ascii_digit ;

// An ID is one of the following:
//
//    1) Any string of alphabetic ([a-zA-Z\200-\377]) characters, underscores
//       ('_') or digits ([0-9]), not beginning with a digit;
//
//    2) a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
//
//    3) any double-quoted string ("...") possibly containing escaped quotes
//       (\")1;
//
//    4) an HTML string (<...>).

// TODO: Check what \200-\377 means in the 1st representation of IDs.
// TODO: Add support for the 2nd, 3rd and 4th representation of IDs.

id
	: _letter { _letter | _decimal_digit }
	| _string_lit
;

_escaped_char : '\\' 'n' ;
_string_lit   : '"' ( _ascii_char | '\'' | _escaped_char ) '"' ;

// TODO: Check which whitespace characters are allowed to separate tokens.

!whitespace : ' ' | '\t' | '\v' | '\f' | '\r' | '\n' ;

// ### [ Syntax ] ##############################################################

<< import (
	"github.com/graphism/dot/gocc/ast"
	"github.com/graphism/dot/gocc/ast/astx"
) >>

// === [ Graphs ] ==============================================================

// Graph : [ "strict" ] ( "graph" | "digraph" ) [ ID ] "{" OptStmtList "}"

Graph
	: OptStrict DirectedGraph OptID
	  "{" OptStmtList "}"                         << astx.NewGraph($0, $1, $2, $4) >>
;

OptStrict
	: empty                                       << false, nil >>
	| strict                                      << true, nil >>
;

DirectedGraph
	: graphx                                      << false, nil >>
	| digraph                                     << true, nil >>
;

// === [ Statements ] ==========================================================

// StmtList
//    : Stmt [ ";" ]
//    | StmtList Stmt [ ";" ]

StmtList
	: Stmt OptSemi                                << astx.NewStmtList($0) >>
	| StmtList Stmt OptSemi                       << astx.AppendStmt($0, $1) >>
;

// TODO: Verify if nil is needed, or if empty returns nil by default.

OptStmtList
	: empty                                       << nil, nil >>
	| StmtList
;

// Stmt
//    : NodeStmt
//    | EdgeStmt
//    | AttrStmt
//    | Attr
//    | Subgraph

Stmt
	: NodeStmt
	| EdgeStmt
	| AttrStmt
	| Attr
	| Subgraph
;

OptSemi
	: empty
	| ";"
;

// --- [ Node statement ] ------------------------------------------------------

// NodeStmt : NodeID [ AttrList ]

NodeStmt
	: NodeID OptAttrList                          << astx.NewNodeStmt($0, $1) >>
;

// --- [ Edge statement ] ------------------------------------------------------

// EdgeStmt : ( NodeID | Subgraph ) Edge [ AttrList ]

EdgeStmt
	: Vertex Edge OptAttrList                     << astx.NewEdgeStmt($0, $1, $2) >>
;

// Edge : ( "--" | "-->" ) ( NodeID | Subgraph ) [ Edge ]

Edge
	: DirectedEdge Vertex OptEdge                 << astx.NewEdge($0, $1, $2) >>
;

DirectedEdge
	: "--"                                        << false, nil >>
	| "->"                                        << true, nil >>
;

// TODO: Verify if nil is needed, or if empty returns nil by default.

OptEdge
	: empty                                       << nil, nil >>
	| Edge
;

// --- [ Attribute statement ] -------------------------------------------------

// AttrStmt : ( "graph" | "node" | "edge" ) AttrList

AttrStmt
	: Component AttrList                          << astx.NewAttrStmt($0, $1) >>
;

Component
	: graphx                                      << ast.KindGraph, nil >>
	| node                                        << ast.KindNode, nil >>
	| edge                                        << ast.KindEdge, nil >>
;

// AttrList : "[" [ AList ] "]" [ AttrList ]

AttrList
	: "[" OptAList "]"                            << $1, nil >>
	| AttrList "[" OptAList "]"                   << astx.AppendAttrList($0, $2) >>
;

// TODO: Verify if nil is needed, or if empty returns nil by default.

OptAttrList
	: empty                                       << nil, nil >>
	| AttrList
;

// AList
//    : Attr [ ( ";" | "," ) ]
//    | AList Attr [ ( ";" | "," ) ]

AList
	: Attr OptSep                                 << astx.NewAttrList($0) >>
	| AList Attr OptSep                           << astx.AppendAttr($0, $1) >>
;

// TODO: Verify if nil is needed, or if empty returns nil by default.

OptAList
	: empty                                       << nil, nil >>
	| AList
;

OptSep
	: empty
	| ";"
	| ","
;

// --- [ Attribute ] -----------------------------------------------------------

Attr
	: ID "=" ID                                   << astx.NewAttr($0, $2) >>
;

// --- [ Subgraph ] ------------------------------------------------------------

// Subgraph : [ "subgraph" [ ID ] ] "{" OptStmtList "}"

Subgraph
	: OptSubgraphID "{" OptStmtList "}"           << astx.NewSubgraph($0, $2) >>
;

OptSubgraphID
	: subgraph OptID                              << $1, nil >>
;

// === [ Vertices ] ============================================================

Vertex
	: NodeID
	| Subgraph
;

// --- [ Node identifier ] -----------------------------------------------------

// NodeID : ID [ Port ]

NodeID
	: ID OptPort                                  << astx.NewNodeID($0, $1) >>
;

// Port
//    : ":" ID [ ":" CompassPoint ]
//    | ":" CompassPoint
//
// CompassPoint
//    : "n" | "ne" | "e" | "se" | "s" | "sw" | "w" | "nw" | "c" | "_"

// Note also that the allowed compass point values are not keywords, so these
// strings can be used elsewhere as ordinary identifiers and, conversely, the
// parser will actually accept any identifier.

Port
	: ":" ID                                      << astx.NewPort($1, nil) >>
	| ":" ID ":" ID                               << astx.NewPort($1, $3) >>
;

// TODO: Verify if nil is needed, or if empty returns nil by default.

OptPort
	: empty                                       << nil, nil >>
	| Port
;

// === [ Identifiers ] =========================================================

ID
	: id                                          << astx.NewID($0) >>
;

OptID
	: empty                                       << "", nil >>
	| ID
;
